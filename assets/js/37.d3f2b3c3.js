(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{344:function(e,s,t){"use strict";t.r(s);var a=t(1),n=Object(a.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"vuepress简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vuepress简介"}},[e._v("#")]),e._v(" VuePress简介")]),e._v(" "),t("p",[e._v("GitHub Pages提供的静态页面托管服务（国内也可以考虑码云提供的Gitee Pages）\nVuePress静态网站生成器\nVuePress是Vue作者尤大的一个作品，其实是用来写文档的，但有vue生态的加持，扩展能力非常强，也很适合搭建博客。VuePress有很多优秀的特性，其可以在md文件中引用vue组件的能力尤其让我痴迷。vuepress其原理与现代前端项目是一致的，基于node平台、webpack驱动的开发方式，打包后为静态页面，可以发布到任意静态服务器上。")]),e._v(" "),t("p",[e._v("官方的描述：\n事实上，一个 VuePress 网站是一个由 Vue、Vue Router 和 webpack 驱动的单页应用。如果你以前使用过 Vue 的话，当你在开发一个自定义主题的时候，会感受到非常熟悉的开发体验，你甚至可以使用 Vue DevTools 去调试你的自定义主题。")]),e._v(" "),t("p",[e._v("在构建时，我们会为应用创建一个服务端渲染（SSR）的版本，然后通过虚拟访问每一条路径来渲染对应的HTML。这种做法的灵感来源于 Nuxt 的 nuxt generate 命令，以及其他的一些项目，比如 Gatsby。")]),e._v(" "),t("p",[e._v("如官方所述，部署版本会采用服务端渲染的方式打包静态资源，这是为了更好的SEO和加载速度。对SEO、SPA->SSR不太了解的朋友可以查一下相关的资料，并且在部署之后，可以体会一下开发模式下和生产版本下，网络响应的差异。")]),e._v(" "),t("h1",{attrs:{id:"vuepress安装步骤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vuepress安装步骤"}},[e._v("#")]),e._v(" VuePress安装步骤")]),e._v(" "),t("p",[e._v("包管理工具，建议使用yarn代替npm，但如果网络情况不好(部署的时候很慢不知道是不是此原因)，可以使用tyarn，是国内某宝的镜像源，建议不要使用cnpm，有点问题。")]),e._v(" "),t("p",[e._v("VuePress官方文档有很详尽的安装教程，这里就搬运一下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n# node 要求 8以上 \n\n# 或者：npm install -g vuepress\nyarn global add vuepress \n\n# 创建vuepress的工程路径\nmkdir myblog\ncd myblog\n\n# 工程初始化\nyarn init -y # 或者 npm init -y\n\n# 文档路径\nmkdir docs\n\n# .vuepress目录\ncd docs\nmkdir .vuepress\n\n# config.js\ncd .vuepress\ntouch config.js\n\n# public目录\nmkdir public\n\n# 设置package.json的脚本配置\n  "scripts": {\n    "dev": "vuepress dev docs",\n    "build": "vuepress build docs"\n  }\n')])])]),t("p",[e._v("完成后的工作目录如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("myblog\n├─── docs\n│   ├── README.md\n│   └── .vuepress\n│       ├── public\n│       └── config.js\n└── package.json\n")])])]),t("p",[e._v("这是vuepress最基本目录结构，其中config.js是网站的基本配置信息，详细配置内容请见官方文档:配置。用vuepress写文档或者博客，其实就是写一个md文件，并将这个文件的路径通过config.js中的路由配置绑定在菜单中，这是它的基本使用方式。")]),e._v(" "),t("p",[e._v("这里插一句，在学习一门新框架或者新工具的时候，遇事不觉，官方文档")]),e._v(" "),t("h1",{attrs:{id:"修改默认主题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#修改默认主题"}},[e._v("#")]),e._v(" 修改默认主题")]),e._v(" "),t("p",[e._v("环境搭建好以后，无需过多的配置，运行npm run dev 就可以访问自己的博客了，如果只是是记录文档，默认的完全符合要求，简洁大方，但如果是做个人博客，一定是需要个性化的东西的。官方文档中，提供了修改默认主题的方式：")]),e._v(" "),t("p",[e._v("你可以使用 vuepress eject [targetDir] 这个命令来将默认主题的源码复制到 .vuepress/theme 文件夹下，从而可以对默认主题进行任意的修改。需要注意的是一旦 eject，即使升级 VuePress 你也无法再获得 VuePress 对默认主题的更新。")]),e._v(" "),t("p",[e._v("下载下来的theme文件夹要放在.vuepress/路径下,做过vue的人，或者有一些前端基础的人，打开这个文件夹，你就会看到vuepress的所有细节，你会看到Home、Layout、Navbar、Sidebar这样如此熟悉的字眼，你可以对样式做任意的修改。")]),e._v(" "),t("p",[e._v("我觉得这样式就挺好，没有对自己的博客做过多的改造")]),e._v(" "),t("h1",{attrs:{id:"ui组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ui组件"}},[e._v("#")]),e._v(" UI组件")]),e._v(" "),t("p",[e._v("vuepress支持扩展，支持引入第三方组件，在.vuepress/下创建enhanceApp.js文件，这里引入vue生态圈比较知名的ui库Element,来自于某外卖厂")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/**\n * 扩展 VuePress 应用\n */\nimport Element from 'element-ui'\nimport 'element-ui/lib/theme-chalk/index.css'\n\nexport default ({\n  Vue, \n}) => {\n  // ...做一些其他的应用级别的优化\n  Vue.use(Element)\n}\n")])])]),t("p",[e._v("当然，在这之前，需要先安装element。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("yarn add element-ui\n")])])]),t("div",{staticStyle:{color:"red"}},[e._v("\n注意：这里出现了第一个坑\n")]),e._v(" "),t("p",[e._v("(先cd到项目目录下？？)")]),e._v(" "),t("p",[e._v("我先用 npm install element-ui@2.7.2")]),e._v(" "),t("p",[e._v("发现安装之后有报错（因为我的package.json 文件中以前是2.7.2所以我以为也要下载这个版本）")]),e._v(" "),t("p",[e._v("修改：npm install element-ui")]),e._v(" "),t("p",[e._v("默认安装最新的版本（package.json 文件中也会自动转为最新的版本）")]),e._v(" "),t("p",[e._v("在扩展之后，就可以在自定义的组件或者md文件中，使用element的组件了。")]),e._v(" "),t("h1",{attrs:{id:"组件开发"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件开发"}},[e._v("#")]),e._v(" 组件开发")]),e._v(" "),t("p",[e._v("vuepress可以在md中可以使用vue组件及语法")]),e._v(" "),t("p",[e._v("如果我们需要开发自己的组件，那么在.vuepress下新建components文件夹，可以在里面编写.vue，与vue-cli开发无异，而且，组件是全局注册的，组件之间互相调用，不用手动引入，在md文件、theme中都可以使用。")]),e._v(" "),t("h1",{attrs:{id:"博客的自动路由"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#博客的自动路由"}},[e._v("#")]),e._v(" 博客的自动路由")]),e._v(" "),t("p",[e._v("vuepress其实是一个文档管理的方案，假如我们做一套开源库api文档，修改与添加文档不会很频繁，所以，采用在config.js中配置路由的形式是很可取，很简单的。比如：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// .vuepress/config.js\nmodule.exports = {\n  themeConfig: {\n    sidebar: {\n      '/foo/': [\n        '',     /* /foo/ */\n        'one',  /* /foo/one.html */\n        'two'   /* /foo/two.html */\n      ],\n\n      '/bar/': [\n        '',      /* /bar/ */\n        'three', /* /bar/three.html */\n        'four'   /* /bar/four.html */\n      ],\n\n      // fallback\n      '/': [\n        '',        /* / */\n        'contact', /* /contact.html */\n        'about'    /* /about.html */\n      ]\n    }\n  }\n}\n")])])]),t("p",[e._v("对于元数据的使用，参考组件BlogList")]),e._v(" "),t("h1",{attrs:{id:"标签墙"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标签墙"}},[e._v("#")]),e._v(" 标签墙")]),e._v(" "),t("p",[e._v("标签墙的实现通过元数据的tags设置标签，在BlogList中，遍历$pages，匹配其中的tag。 页面可以参照组件Tags")]),e._v(" "),t("h1",{attrs:{id:"评论功能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#评论功能"}},[e._v("#")]),e._v(" 评论功能")]),e._v(" "),t("p",[e._v("评论功能的集成，使用的是网上比较流行的valine组件：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("yarn add leancloud-storage\nyarn add valine\n")])])]),t("p",[e._v("对于组件的封装可以参见Valine.vue,")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n    new Valine({\n      el: '#vcomments' ,\n      appId: '',// your appId\n      appKey: '', // your appKey\n      notify:true, \n      verify:false, \n      avatar:'mm', \n      placeholder: 'just go go' \n    });\n")])])]),t("p",[e._v("其中 appid 与appkey 需要在leancloud中注册获得。")]),e._v(" "),t("p",[e._v("详细的内容，原作者有详尽的说明：云淡风轻")]),e._v(" "),t("div",{staticStyle:{color:"red"}},[e._v("\n注意：这里出现了第二个坑\n")]),e._v(" "),t("p",[e._v("这个功能确实强大，但是需要实名验证，交费啥的，挺麻烦，现阶段个人使用不太需要，暂时不用；但是如果不填的话，编译的时候会报错；")]),e._v(" "),t("p",[e._v("我的做法是：去除这个模块，和这个功能模块相关的东西全部删掉，也许有开关啥的，我没有深究")]),e._v(" "),t("h1",{attrs:{id:"githubpages部署"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#githubpages部署"}},[e._v("#")]),e._v(" GitHubPages部署")]),e._v(" "),t("p",[e._v("在你的个人博客已经创建就绪之后，我们需要做的就是发布它，这需要以下几步：")]),e._v(" "),t("p",[e._v("本机安装git，有github账号，这一点不赘述。")]),e._v(" "),t("p",[e._v("创建一个 “用户名.github.io” 这样的仓库，")]),e._v(" "),t("p",[e._v("进入仓库 ，在settings中，找到 github pages的设置。")]),e._v(" "),t("p",[e._v("github官方是给提供模板的，可以先选一个，在替换成我们的个人博客的时候，要把分支先pull下来，清除原有文件。")]),e._v(" "),t("p",[e._v("也可以直接在仓库根路径下方一个index.html,随便写点内容，以验证我们的页面是否可以访问")]),e._v(" "),t("p",[e._v("以上步骤网上资料非常多，善用百度。在一切准备就绪之后，可以试试浏览器直接访问自己的主页：用户名.github.io。")]),e._v(" "),t("p",[e._v("之后的事情，我们可以写一个自动发布的脚本：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("# 构建\nnpm run build\n# 导航到构建输出目录\ncd docs/.vuepress/dist\n\ngit init\ngit add -A\ngit commit -m 'deploy'\n\n# 推到你仓库的 master 分支\ngit push -f git@github.com:yourname/yourname.github.io.git master\n\n")])])]),t("p",[e._v("我的自动脚本")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("# 自动部署脚本  \n\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n\n# 构建\nnpm run build\n# 导航到构建输出目录\ncd docs/.vuepress/dist\n\ngit init\ngit add -A\ngit commit -m 'deploy'\n\n# 推到你仓库的 master 分支\n\ngit push -f git@github.com:yourname/yourname.github.io.git master\n\n\ncd -\n")])])]),t("p",[e._v("参考文章：\nhttps://www.cnblogs.com/softidea/p/10084946.html")]),e._v(" "),t("p",[e._v("build之后，默认会将静态打包文件放在.vuepress/dist下，我们只需把这个文件夹里的内容提交到仓库里即可。")]),e._v(" "),t("p",[e._v("每次写了新博客，都可以通过这个脚本发布。")]),e._v(" "),t("p",[e._v("每次发布只需要在对应的目录添加md文件，然后切换到对应的仓库下")]),e._v(" "),t("p",[e._v("cd /yourProject/")]),e._v(" "),t("p",[e._v("npm run deploy")]),e._v(" "),t("p",[e._v("每次发布之后记得到githubpage设置界面重新绑定下域名，因为每次发布，他会重制下")]),e._v(" "),t("h1",{attrs:{id:"nginx部署"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nginx部署"}},[e._v("#")]),e._v(" Nginx部署")]),e._v(" "),t("p",[e._v("更推荐的方式还是服务器部署，国内暂时不支持githubpages的SEO。所以，如果你想让你的文章可以被大众搜索到，最好还是弄一台服务器。腾讯云有校园优惠，首次购买腾讯云产品，可以享受1核2G一年120元的优惠。部署个nginx，可以了。")]),e._v(" "),t("p",[e._v("通过nginx部署静态网站的资料，网上非常多，请善用百度。")]),e._v(" "),t("h1",{attrs:{id:"绑定域名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#绑定域名"}},[e._v("#")]),e._v(" 绑定域名")]),e._v(" "),t("p",[e._v("到这一步，博客已经可以通过url： ***.github.io（或者云服务器的IP） 访问了。")]),e._v(" "),t("p",[e._v("但是最好要有一个自己的域名。 在购买域名的时候，需要上传个人信息的，住址、身份证信息等，相关部门以及机构需要登记审核。但审核期间完全可以正常使用，如果审核未通过，则会被停用。 在购买域名后，需要配置域名解析，这也就是花钱买域名的意义，通过dns,将买来的域名解析到github pages上。如何设置，可以参考我的上一篇博客")]),e._v(" "),t("h1",{attrs:{id:"结语"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[e._v("#")]),e._v(" 结语")]),e._v(" "),t("p",[e._v("这个项目还挺方便的，很简洁，没有太多时间雕琢，比较简陋，仅当记录自已的一个工具。")])])}],!1,null,null,null);s.default=n.exports}}]);